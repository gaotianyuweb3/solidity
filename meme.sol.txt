// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// å¼•å…¥ OpenZeppelin çš„ ERC20 æ ‡å‡†å®ç°
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
// å¼•å…¥ Ownableï¼Œä¾¿äºè®¾ç½®ä»…ç®¡ç†å‘˜å¯è°ƒç”¨çš„å‡½æ•°
import "@openzeppelin/contracts/access/Ownable.sol";

contract MemeToken is ERC20, Ownable {
    // æ€»ç¨è´¹æ¯”ä¾‹ï¼ˆç™¾åˆ†æ¯”ï¼Œå•ä½æ˜¯æ•´æ•° 5 è¡¨ç¤º 5%ï¼‰
    uint256 public taxFee = 5;
    // ç¨ä¸­ç”¨äºé”€æ¯çš„æ¯”ä¾‹
    uint256 public burnFee = 2;
    // ç¨ä¸­ç”¨äºæ‰“å…¥è¥é”€é’±åŒ…çš„æ¯”ä¾‹
    uint256 public marketingFee = 3;
    // è¥é”€é’±åŒ…åœ°å€
    address public marketingWallet;
    // å•åœ°å€æœ€å¤§æŒå¸é‡ï¼ˆæŒ‰æ€»é‡ç™¾åˆ†æ¯”ï¼‰
    uint256 public maxWalletPercent = 2;
    // ä»£å¸æ€»ä¾›åº”é‡ï¼ˆ10 äº¿ * 10^18ï¼‰
    uint256 public totalSupplyAmount = 1_000_000_000 * 1e18;

    // è®°å½•å“ªäº›åœ°å€æ˜¯å…ç¨çš„
    mapping(address => bool) private _isExcludedFromFee;

    // æ„é€ å‡½æ•°ï¼šéƒ¨ç½²æ—¶è°ƒç”¨ï¼Œåˆå§‹åŒ–åç§°ã€ç¬¦å·å’Œæ€»ä¾›åº”é‡
    constructor(address _marketingWallet) ERC20("MemeToken", "MEME") {
        marketingWallet = _marketingWallet;
        // Mint ç»™éƒ¨ç½²è€…å…¨éƒ¨åˆå§‹ä»£å¸
        _mint(msg.sender, totalSupplyAmount);
        // éƒ¨ç½²è€…å’Œè¥é”€é’±åŒ…é»˜è®¤å…ç¨
        _isExcludedFromFee[msg.sender] = true;
        _isExcludedFromFee[marketingWallet] = true;
    }

    // é‡å†™è½¬è´¦é€»è¾‘ï¼Œå®ç°ç¨è´¹å’Œé™åˆ¶åŠŸèƒ½
    function _transfer(address sender, address recipient, uint256 amount) internal override {
        // å¦‚æœå‘é€è€…æˆ–æ¥æ”¶è€…æ˜¯å…ç¨åœ°å€ï¼Œç›´æ¥è½¬è´¦
        if (_isExcludedFromFee[sender] || _isExcludedFromFee[recipient]) {
            super._transfer(sender, recipient, amount);
            return;
        }

        // åˆ¤æ–­æ¥æ”¶è€…æ˜¯å¦è¶…è¿‡æœ€å¤§æŒå¸é™åˆ¶ï¼ˆåé²¸é±¼ï¼‰
        require(
            balanceOf(recipient) + amount <= (totalSupply() * maxWalletPercent / 100),
            "Exceeds max wallet limit"
        );

        // è®¡ç®—æ€»ç¨è´¹
        uint256 taxAmount = (amount * taxFee) / 100;
        // è®¡ç®—é”€æ¯éƒ¨åˆ†
        uint256 burnAmount = (amount * burnFee) / 100;
        // è®¡ç®—è¥é”€éƒ¨åˆ†
        uint256 marketingAmount = (amount * marketingFee) / 100;
        // å®é™…å‘é€çš„é‡‘é¢ï¼ˆå‡å»å…¨éƒ¨ç¨è´¹ï¼‰
        uint256 netAmount = amount - taxAmount;

        // æ‰§è¡Œé”€æ¯æ“ä½œï¼ˆå‡å°‘æ€»ä¾›åº”é‡ï¼‰
        _burn(sender, burnAmount);

        // å°†è¥é”€è´¹ç”¨è½¬ç»™è¥é”€é’±åŒ…
        super._transfer(sender, marketingWallet, marketingAmount);

        // å°†å‰©ä½™ä»£å¸å‘é€ç»™æ”¶æ¬¾åœ°å€
        super._transfer(sender, recipient, netAmount - burnAmount - marketingAmount);
    }

    // ğŸ›  ç®¡ç†å‡½æ•°ï¼šè®¾ç½®å„é¡¹ç¨ç‡ï¼ˆä»…é™åˆçº¦æ‹¥æœ‰è€…è°ƒç”¨ï¼‰
    function setFees(uint256 _tax, uint256 _burn, uint256 _marketing) external onlyOwner {
        require(_tax == _burn + _marketing, "Tax must equal burn + marketing");
        taxFee = _tax;
        burnFee = _burn;
        marketingFee = _marketing;
    }

    // è®¾ç½®è¥é”€é’±åŒ…åœ°å€
    function setMarketingWallet(address _wallet) external onlyOwner {
        marketingWallet = _wallet;
        _isExcludedFromFee[_wallet] = true;
    }

    // è®¾ç½®æŸä¸ªåœ°å€æ˜¯å¦å…ç¨
    function excludeFromFee(address _addr, bool _excluded) external onlyOwner {
        _isExcludedFromFee[_addr] = _excluded;
    }

    // è®¾ç½®æœ€å¤§æŒå¸ä¸Šé™ï¼ˆæŒ‰ç™¾åˆ†æ¯”ï¼‰
    function setMaxWalletPercent(uint256 _percent) external onlyOwner {
        require(_percent >= 1 && _percent <= 100, "Invalid %");
        maxWalletPercent = _percent;
    }
}
